# Aura Quiet Living - 立项与可行性分析

## 📋 一、立项背景

### 1.1 项目定位
**Aura Quiet Living** 是一个基于 Spring AI 的智能电商平台，旨在展示 10 大核心 AI Agent 能力的综合应用。

### 1.2 立项过程

#### 阶段一：技术范围确定
小组内讨论确定技术栈范围：
- **后端框架**: Spring Boot 3.2 + Spring AI
- **前端框架**: React 19.2 + TypeScript
- **AI 能力**: OpenAI GPT-4o-mini
- **数据存储**: MySQL 8.0 + SimpleVectorStore

#### 阶段二：项目提案
每位组员提出项目想法，最终确定：
- **选定方向**: AI 驱动的电商平台
- **核心价值**: 展示 Spring AI 的 10 大能力
- **应用场景**: 智能客服、产品推荐、订单管理

#### 阶段三：最终决策
通过小组会议投票，确定项目名称和定位：
- **品牌名称**: Aura（灵气）
- **品牌理念**: Quiet Living（静谧生活）
- **目标用户**: 追求科技与自然平衡的消费者

---

## 🔍 二、可行性分析

### 2.1 技术可行性

#### 2.1.1 后端技术栈

| 技术 | 用途 | 团队掌握情况 | 可行性 |
|------|------|--------------|--------|
| **Java 17** | 核心语言 | ✅ 所有人掌握 | ✅ 高 |
| **Spring Boot 3.2** | 应用框架 | ✅ 所有人掌握 | ✅ 高 |
| **Spring AI** | AI 集成 | ⚠️ 1/6 人掌握 | ✅ 中高（有学习曲线） |
| **MySQL 8.0** | 关系数据库 | ✅ 所有人掌握 | ✅ 高 |
| **Maven** | 构建工具 | ✅ 所有人掌握 | ✅ 高 |
| **JPA/Hibernate** | ORM 框架 | ✅ 5/6 人掌握 | ✅ 高 |
| **OpenAI API** | LLM 服务 | ⚠️ 1/6 人掌握 | ✅ 中（有文档支持） |
| **Apache PDFBox** | PDF 处理 | ⚠️ 0/6 人掌握 | ✅ 低（用于 RAG） |

#### 2.1.2 前端技术栈（AI生成前端）

| 技术 | 用途 | 团队掌握情况 | 可行性 |
|------|------|--------------|--------|
| **React 19.2** | UI 框架 | ✅ 0/6 人掌握 | ✅ 低 |
| **TypeScript** | 类型安全 | ✅ 4/6 人掌握 | ✅ 高 |
| **Vite** | 构建工具 | ⚠️ 3/6 人掌握 | ✅ 中高 |
| **Tailwind CSS** | 样式框架 | ✅ 4/6 人掌握 | ✅ 高 |
| **Axios** | HTTP 客户端 | ✅ 所有人掌握 | ✅ 高 |

#### 2.1.3 数据持久化方案

**选择：MySQL 8.0（关系型数据库）+ SimpleVectorStore（向量存储）**

- **MySQL**: 存储结构化数据（产品、订单、用户）
  - ✅ 所有人掌握
  - ✅ 支持事务和复杂查询
  - ✅ 本地部署，无需云服务费用

- **SimpleVectorStore**: 存储向量数据（RAG 知识库）
  - ⚠️ 1/6 人掌握
  - ✅ Spring AI 内置支持
  - ✅ 适合演示项目规模

**替代方案考虑**：
- ❌ MongoDB：团队不熟悉，学习成本高
- ❌ Redis：仅用于缓存，不适合主存储
- ❌ 云数据库：增加成本和部署复杂度

#### 2.1.4 界面技术选择

**选择：Web 界面（React + Tailwind CSS）**

- ✅ 跨平台访问
- ✅ 团队熟悉度高（4/6 人）
- ✅ 开发效率高
- ✅ 易于展示和演示

**替代方案考虑**：
- ❌ 控制台：用户体验差
- ❌ Swing：过时技术
- ❌ Qt：学习成本高
- ❌ UE：过度设计

#### 2.1.5 其他关键技术

| 技术 | 用途 | 掌握情况 | 必要性 |
|------|------|----------|--------|
| **RESTful API** | 前后端通信 | ✅ 所有人 | ✅ 必需 |
| **CORS** | 跨域处理 | ✅ 4/6 人 | ✅ 必需 |
| **JWT（初版不实现）** | 身份认证 | ⚠️ 2/6 人 | ⚠️ 可选（演示项目） |
| **Lombok** | 代码简化 | ✅ 5/6 人 | ✅ 推荐 |
| **SLF4J + Logback** | 日志记录 | ✅ 所有人 | ✅ 必需 |

---

### 2.2 功能可行性

#### 2.2.1 核心功能列表

##### 电商基础功能
1. **产品管理**
   - 产品列表展示
   - 产品详情查看
   - 产品搜索（关键词）
   - 产品分类筛选

2. **购物车**
   - 添加商品到购物车
   - 修改商品数量
   - 删除购物车商品
   - 购物车持久化

3. **订单管理**
   - 创建订单
   - 查询订单状态
   - 修改配送地址
   - 模拟支付（自动成功）

##### AI Agent 核心功能（10 大能力）

4. **Prompt Engineering（提示工程）**
   - 品牌人格设定
   - 对话风格控制
   - 上下文理解

5. **RAG（检索增强生成）**
   - 产品说明书 PDF 解析
   - 向量化存储
   - 语义检索
   - 知识问答

6. **Memory（记忆管理）**
   - 会话级记忆
   - 用户级记忆
   - 长期记忆存储

7. **Function Calling（函数调用）**
   - 查询产品信息
   - 搜索产品
   - 查询订单状态
   - 修改配送地址
   - 推荐产品
   - 获取购物车信息
   - 计算价格
   - 获取物流信息

8. **Complex Task（复杂任务）**
   - 多步骤任务编排
   - 自动任务分解
   - 上下文传递

9. **Multi-Agent（多智能体）**
   - Orchestrator Agent（协调者）
   - Product Agent（产品专家）
   - Order Agent（订单专家）
   - Customer Service Agent（客服）

10. **Planning（任务规划）**
    - ReAct 模式
    - 思考-行动-观察循环
    - 动态计划调整

11. **Tool Chain（工具链）**
    - 工具组合使用
    - 工具依赖管理
    - 结果传递

12. **Error Handling（错误处理）**
    - 智能错误恢复
    - 降级策略
    - 用户友好提示

13. **Reflection（反思机制）**
    - 自我评估
    - 结果验证
    - 持续改进

#### 2.2.2 功能优先级

| 优先级 | 功能模块 | 开发周期 | 依赖关系 |
|--------|----------|----------|----------|
| **P0** | 产品管理 + 基础 AI 对话 | 2 天 | 无 |
| **P0** | 订单管理 + Function Calling | 2 天 | 产品管理 |
| **P1** | RAG（PDF 知识库） | 1.5 天 | 基础 AI |
| **P1** | Memory（记忆管理） | 1 天 | 基础 AI |
| **P1** | Multi-Agent（多智能体） | 2 天 | Function Calling |
| **P2** | 前端界面优化 | 1.5 天 | 所有后端 API |
| **P2** | 测试 + 文档 | 1 天 | 所有功能 |

---

### 2.3 数据模型可行性

#### 2.3.1 核心数据对象

##### 1. Product（产品）
```java
{
  id: String              // 产品唯一标识（如 "p1"）
  name: String            // 产品名称（如 "Aura Harmony"）
  category: String        // 分类（Audio/Wearable/Mobile/Home）
  price: Double           // 价格（如 429.00）
  description: String     // 产品描述
  features: List<String>  // 特性列表
  imageUrl: String        // 产品图片 URL
  manualPath: String      // 说明书 PDF 路径（可选）
  stock: Integer          // 库存数量
  createdAt: Timestamp    // 创建时间
  updatedAt: Timestamp    // 更新时间
}
```

##### 2. Order（订单）
```java
{
  id: Long                // 订单 ID（自增）
  orderNumber: String     // 订单号（如 "ORD-20260127-001"）
  userId: String          // 用户 ID（演示项目可为固定值）
  items: List<OrderItem>  // 订单项列表
  totalAmount: Double     // 总金额
  shippingAddress: String // 配送地址
  status: OrderStatus     // 订单状态（PENDING/PAID/SHIPPED/DELIVERED）
  paymentMethod: String   // 支付方式（MOCK）
  createdAt: Timestamp    // 下单时间
  updatedAt: Timestamp    // 更新时间
}
```

##### 3. OrderItem（订单项）
```java
{
  id: Long                // 订单项 ID
  orderId: Long           // 所属订单 ID
  productId: String       // 产品 ID
  productName: String     // 产品名称（冗余存储）
  quantity: Integer       // 数量
  price: Double           // 单价（下单时价格）
  subtotal: Double        // 小计
}
```

##### 4. ChatMessage（聊天消息）
```java
{
  id: Long                // 消息 ID
  sessionId: String       // 会话 ID
  role: String            // 角色（USER/ASSISTANT/SYSTEM）
  content: String         // 消息内容
  metadata: JSON          // 元数据（如函数调用记录）
  createdAt: Timestamp    // 创建时间
}
```

##### 5. VectorDocument（向量文档）
```java
{
  id: String              // 文档 ID
  content: String         // 文档内容
  embedding: float[]      // 向量表示
  metadata: Map           // 元数据（如来源 PDF、页码）
  productId: String       // 关联产品 ID（可选）
}
```

##### 6. CartItem（购物车项）
```java
{
  id: Long                // 购物车项 ID
  userId: String          // 用户 ID
  productId: String       // 产品 ID
  quantity: Integer       // 数量
  addedAt: Timestamp      // 添加时间
}
```

#### 2.3.2 数据关系图

```
Product (1) ----< (N) OrderItem (N) >---- (1) Order
   |                                          |
   |                                          |
   v                                          v
VectorDocument                           ChatMessage
   (RAG 知识库)                            (对话历史)

CartItem (N) >---- (1) Product
```

#### 2.3.3 数据库设计可行性

| 表名 | 预估记录数 | 索引策略 | 查询频率 |
|------|-----------|----------|----------|
| `products` | ~10 条 | PRIMARY KEY (id), INDEX (category) | 高 |
| `orders` | ~100 条 | PRIMARY KEY (id), UNIQUE (orderNumber) | 中 |
| `order_items` | ~300 条 | PRIMARY KEY (id), INDEX (orderId) | 中 |
| `chat_messages` | ~1000 条 | PRIMARY KEY (id), INDEX (sessionId) | 高 |
| `cart_items` | ~50 条 | PRIMARY KEY (id), INDEX (userId) | 中 |

**结论**：数据规模小，MySQL 完全可以胜任，无需分库分表。

---

### 2.4 时间可行性

#### 2.4.1 团队配置
- **团队规模**: 6 人
- **开发周期**: 8-9 天
- **工作模式**: 全职开发

#### 2.4.2 任务分工

详见 [团队分工详细方案.md](./团队分工详细方案.md)

| 成员 | 主要职责 | 类数量 | 预计时间 |
|------|----------|--------|----------|
| 成员 A | AI 核心架构（RAG + Multi-Agent） | 6 个类 | 4 天 |
| 成员 B | 业务逻辑 + ProductExpertAgent | 6 个类 | 3-4 天 |
| 成员 C | AI Functions（Function Calling） | 6 个类 | 3-4 天 |
| 成员 D | AI Agents + Memory | 6 个类 | 4 天 |
| 成员 E | Prompt 设计 + 实体类 | 5 个类 | 3-4 天 |
| 成员 F | 前端集成 + Controller + DTO | 6 个类 + 前端 | 3-4 天 |

#### 2.4.3 开发计划

| 阶段 | 天数 | 交付物 |
|------|------|--------|
| **Day 1**: 基础架构 | 1 天 | Spring AI 配置、实体类、Repository |
| **Day 2**: 核心服务 | 1 天 | ProductService、OrderService、AI Functions |
| **Day 3**: AI Agents | 1 天 | ProductExpertAgent、OrchestratorAgent、CustomerServiceAgent |
| **Day 4**: 集成和前端 | 1 天 | MultiAgentService、AIAgentService、前端 AI 聊天界面 |

**结论**：时间安排紧凑但可行，每个成员负责 5-6 个类，工作量平衡。

---

### 2.5 成本可行性

#### 2.5.1 开发成本

| 项目 | 费用 | 说明 |
|------|------|------|
| **人力成本** | ¥0 | 学生项目 |
| **OpenAI API** | ~¥50-100 | gpt-4o-mini 便宜（开发+演示） |
| **服务器** | ¥0 | 本地部署 |
| **域名/SSL** | ¥0 | 不需要（演示项目） |
| **其他工具** | ¥0 | 全部使用开源工具 |

**总成本**: ≤ ¥100（主要是 OpenAI API 调用费用）

#### 2.5.2 风险成本

| 风险 | 概率 | 影响 | 应对策略 |
|------|------|------|----------|
| OpenAI API 超支 | 中 | 低 | 设置使用上限、使用 gpt-3.5-turbo 降级 |
| 技术学习曲线 | 高 | 中 | 提前学习 Spring AI 文档、结对编程 |
| 进度延期 | 中 | 中 | 每日站会、及时调整优先级 |
| 功能砍掉 | 低 | 低 | P0 功能优先、P2 功能可选 |

**结论**：成本极低，风险可控。

---

### 2.6 技术风险评估

#### 2.6.1 高风险项

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| **Spring AI 学习曲线** | 可能延期 1-2 天 | 提前阅读官方文档、参考示例代码 |
| **RAG 向量化效果** | 知识问答不准确 | 使用高质量 PDF、调整 chunk 大小 |
| **Multi-Agent 协调** | 逻辑复杂易出错 | 先实现单 Agent、逐步扩展 |

#### 2.6.2 中风险项

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| **前后端联调** | 接口不匹配 | 提前定义 API 契约、使用 OpenAPI |
| **OpenAI API 限流** | 演示时失败 | 本地缓存、Mock 数据备份 |
| **MySQL 性能** | 查询慢 | 添加索引、优化查询语句 |

#### 2.6.3 低风险项

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| **Git 冲突** | 合并困难 | 遵循分支策略、频繁 pull |
| **环境配置** | 本地运行失败 | 提供详细 README、Docker 化（可选） |

---

## ✅ 三、可行性结论

### 3.1 综合评估

| 维度 | 评分 | 说明 |
|------|------|------|
| **技术可行性** | ⭐⭐⭐⭐⭐ | 技术栈成熟，团队掌握度高 |
| **功能可行性** | ⭐⭐⭐⭐☆ | 核心功能明确，AI 能力有挑战 |
| **数据可行性** | ⭐⭐⭐⭐⭐ | 数据模型清晰，规模可控 |
| **时间可行性** | ⭐⭐⭐⭐☆ | 时间紧张但可行，需严格执行 |
| **成本可行性** | ⭐⭐⭐⭐⭐ | 成本极低，风险可控 |

**总体评分**: ⭐⭐⭐⭐⭐ (4.6/5.0)

### 3.2 关键成功因素

1. ✅ **技术栈选择合理**: Spring Boot + React 是成熟组合
2. ✅ **团队技能匹配**: 大部分技术团队已掌握
3. ✅ **功能范围明确**: 10 大 AI 能力清晰可衡量
4. ✅ **数据模型简洁**: 5 个核心实体，关系清晰
5. ✅ **开发计划详细**: 分阶段交付，风险可控
6. ✅ **成本极低**: 仅需少量 API 费用

### 3.3 潜在挑战

1. ⚠️ **Spring AI 学习**: 需要 2-3 天熟悉框架
2. ⚠️ **RAG 调优**: 向量化效果需要实验调整
3. ⚠️ **Multi-Agent 协调**: 逻辑复杂，需要仔细设计
4. ⚠️ **时间压力**: 8-9 天开发周期较紧张

### 3.4 最终决策

**✅ 项目可行，建议立项！**

**理由**：
1. 技术栈成熟，团队掌握度高（80%+）
2. 功能范围明确，可分阶段交付
3. 成本极低（≤¥100），风险可控
4. 有完整的开发计划和应对策略
5. 展示价值高（10 大 Spring AI 能力）

**建议**：
1. 提前 1-2 天进行 Spring AI 技术预研
2. 优先实现 P0 功能，确保核心可用
3. 每日站会同步进度，及时调整计划
4. 准备 Mock 数据，应对演示时 API 失败

---

## 📊 四、附录

### 4.1 技术选型对比

#### 后端框架
| 框架 | 优势 | 劣势 | 选择 |
|------|------|------|------|
| Spring Boot | 生态完善、团队熟悉 | 较重 | ✅ 选择 |
| Node.js | 轻量、全栈统一 | 团队不熟悉 | ❌ |
| Django | Python AI 生态好 | 团队不熟悉 | ❌ |

#### 前端框架
| 框架 | 优势 | 劣势 | 选择 |
|------|------|------|------|
| React | 生态丰富、团队熟悉 | 学习曲线 | ✅ 选择 |
| Vue | 简单易学 | 团队不熟悉 | ❌ |
| Angular | 企业级 | 过于复杂 | ❌ |

#### 数据库
| 数据库 | 优势 | 劣势 | 选择 |
|--------|------|------|------|
| MySQL | 成熟稳定、团队熟悉 | 扩展性一般 | ✅ 选择 |
| PostgreSQL | 功能强大 | 团队不熟悉 | ❌ |
| MongoDB | 灵活 | 团队不熟悉 | ❌ |

### 4.2 参考资料

- [Spring AI 官方文档](https://docs.spring.io/spring-ai/reference/)
- [OpenAI API 文档](https://platform.openai.com/docs)
- [React 官方文档](https://react.dev/)
- [项目 ARCHITECTURE.md](./ARCHITECTURE.md)
- [项目 DEVELOPMENT_STANDARDS.md](./DEVELOPMENT_STANDARDS.md)

---

**文档版本**: 1.0  
**创建日期**: 2026-01-27  
**最后更新**: 2026-01-27  
**审核状态**: ✅ 已通过
